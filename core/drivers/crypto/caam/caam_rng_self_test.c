// SPDX-License-Identifier: BSD-2-Clause
/*
 * Copyright 2018, 2021 NXP
 * Copyright (C) 2021 Foundries.io, Michael Scott <mike@foundries.io>
 *
 * Based on patch gathered from NXP Community Forums:
 * https://community.nxp.com/t5/i-MX-Processors/Using-dek-blob-command-in-i-MX6QP-Wandboard-QuadPlus/m-p/786035/highlight/true#M121834
 * Linking to: https://portland.source.codeaurora.org/patches/external/imxsupport/uboot-imx/imx_v2016.03_4.1.15_2.0.0_ga/HAB-238-Run-RNG-self-test-for-impacted-i.MX-chips.zip
 *
 * | From: Utkarsh Gupta <utkarsh.gupta@nxp.com>
 * | Date: Thu, 22 Feb 2018 12:59:03 -0600
 * | Subject: [PATCH] HAB-238 Run RNG self test for impacted i.MX chips
 * |
 * | Patch is only applicable to imx_v2016.03_4.1.15_2.0.0_ga branch of u-boot.
 * | Please adapt the patch for your respective release version.
 * |
 * | Background:
 * | Few i.MX chips which have HAB 4.2.3 or beyond, have oberserved following
 * | warning message generated by HAB due to incorrect implementation of drng
 * | self test in boot ROM.
 * |
 * |     Event       |0xdb|0x0024|0x42| SRCE Field: 69 30 e1 1d
 * |                 |    |      |    |             STS = HAB_WARNING (0x69)
 * |                 |    |      |    |             RSN = HAB_ENG_FAIL (0x30)
 * |                 |    |      |    |             CTX = HAB_CTX_ENTRY (0xE1)
 * |                 |    |      |    |             ENG = HAB_ENG_CAAM (0x1D)
 * |                 |    |      |    | Evt Data (hex):
 * |                 |    |      |    |  00 08 00 02 40 00 36 06 55 55 00 03 00 00 00 00
 * |                 |    |      |    |  00 00 00 00 00 00 00 00 00 00 00 01
 * |
 * | It is recommended to run this rng self test before any RNG related crypto
 * | implementations are done.
 * |
 * | Implementation:
 * | Enable following configuration in board file:
 * |
 * | CONFIG_SECURE_BOOT
 * | CONFIG_SYS_FSL_SEC_LE
 * | CONFIG_SYS_FSL_SEC_COMPAT       4
 * | CONFIG_FSL_CAAM
 * | CONFIG_CMD_RNG_SELF_TEST
 * |
 * | This patch also introduces a MACRO called CONFIG_RNG_INIT. This MACRO should
 * | be defined only when RNG initialization is needed. For ex: DEK blob tool.
 * |
 * | Impacted chips known:
 * |
 * | i.MX6SX Rev 1.4
 * | i.MX6DQP Rev 1.1
 * | i.MX6UL Rev 1.2
 * | i.MX7D Rev 1.3
 * | i.MX6DQ Rev 1.6
 * |
 * | Signed-off-by: Utkarsh Gupta <utkarsh.gupta@nxp.com>
 */

#include <atomic.h>
#include <caam_common.h>
#include <caam_hal_ctrl.h>
#include <caam_hal_rng.h>
#include <caam_io.h>
#include <caam_jr.h>
#include <caam_rng.h>
#include <caam_utils_mem.h>
#include <crypto/crypto.h>
#include <kernel/panic.h>
#include <mm/core_memprot.h>
#include <rng_support.h>
#include <tee/cache.h>
#include <tee/tee_cryp_utl.h>
#include <string.h>

#include "hal/common/registers/version_regs.h"

static const uint32_t rng_self_test_desc1[] = {
	0xb0800036, 0x04800010, 0x3c85a15b, 0x50a9d0b1,
	0x71a09fee, 0x2eecf20b, 0x02800020, 0xb267292e,
	0x85bf712d, 0xe85ff43a, 0xa716b7fb, 0xc40bb528,
	0x27b6f564, 0x8821cb5d, 0x9b5f6c26, 0x12a00020,
	0x0a20de17, 0x6529357e, 0x316277ab, 0x2846254e,
	0x34d23ba5, 0x6f5e9c32, 0x7abdc1bb, 0x0197a385,
	0x82500405, 0xa2000001, 0x10880004, 0x00000005,
	0x12820004, 0x00000020, 0x82500001, 0xa2000001,
	0x10880004, 0x40000045, 0x02800020, 0x8f389cc7,
	0xe7f7cbb0, 0x6bf2073d, 0xfc380b6d, 0xb22e9d1a,
	0xee64fcb7, 0xa2b48d49, 0xdf9bc3a4, 0x82500009,
	0xa2000001, 0x10880004, 0x00000005, 0x82500001,
	0x60340020, 0xFFFFFFFF, 0xa2000001, 0x10880004,
	0x00000005, 0x8250000d
};

static const uint8_t rng_self_test_result1[] = {
	0x3a, 0xfe, 0x2c, 0x87, 0xcc, 0xb6, 0x44, 0x49,
	0x19, 0x16, 0x9a, 0x74, 0xa1, 0x31, 0x8b, 0xef,
	0xf4, 0x86, 0x0b, 0xb9, 0x5e, 0xee, 0xae, 0x91,
	0x92, 0xf4, 0xa9, 0x8f, 0xb0, 0x37, 0x18, 0xa4
};

static const uint32_t rng_self_test_desc2[] = {
	0xb080003a, 0x04800020, 0x27b73130, 0x30b4b10f,
	0x7c62b1ad, 0x77abe899, 0x67452301, 0xefcdab89,
	0x98badcfe, 0x10325476, 0x02800020, 0x63f757cf,
	0xb9165584, 0xc3c1b407, 0xcc4ce8ad, 0x1ffe8a58,
	0xfb4fa893, 0xbb5f4af0, 0x3fb946a1, 0x12a00020,
	0x56cbcaa5, 0xfff3adad, 0xe804dcbf, 0x9a900c71,
	0xa42017e3, 0x826948e2, 0xd0cfeb3e, 0xaf1a136a,
	0x82500405, 0xa2000001, 0x10880004, 0x00000005,
	0x12820004, 0x00000020, 0x82500001, 0xa2000001,
	0x10880004, 0x40000045, 0x02800020, 0x2e882f8a,
	0xe929943e, 0x8132c0a8, 0x12037f90, 0x809fbd66,
	0x8684ea04, 0x00cbafa7, 0x7b82d12a, 0x82500009,
	0xa2000001, 0x10880004, 0x00000005, 0x82500001,
	0x60340020, 0xFFFFFFFF, 0xa2000001, 0x10880004,
	0x00000005, 0x8250000d
};

static const uint8_t rng_self_test_result2[] = {
	0x76, 0x87, 0x66, 0x4e, 0xd8, 0x1d, 0x1f, 0x43,
	0x76, 0x50, 0x85, 0x5d, 0x1e, 0x1d, 0x9d, 0x0f,
	0x93, 0x75, 0x83, 0xff, 0x9a, 0x9b, 0x61, 0xa9,
	0xa5, 0xeb, 0xa3, 0x28, 0x2a, 0x15, 0xc1, 0x57
};

/*
 * caam_desc_add_self_test() - copy desc and handle result addr replacement
 *
 * Returns zero on success,and negative on error.
 */
static int caam_desc_add_self_test(uint32_t *desc,
				   const uint32_t *self_test_desc,
				   int self_test_desc_size,
				   struct caambuf *result)
{
	int i;

	if (!desc) {
		EMSG("RNG self test descriptor construction failed\n");
		return -1;
	}

	/*
	 * Skip header word in self test desc: it's meta data and is
	 * calculated using caam_desc_* APIs.
	 * Kept for comparison to generated desc.
	 */
	for (i = 1; i < self_test_desc_size; i++) {
		/* Replace placeholder address in the result addr */
		if (self_test_desc[i] == 0xFFFFFFFF)
			caam_desc_add_ptr(desc, result->paddr);
		else
			caam_desc_add_word(desc, self_test_desc[i]);
	}

	return 0;
}

/*
 * caam_rng_self_test() - Perform RNG self test
 * Returns CAAM_NO_ERROR on success, otherwise CAAM error.
 */
enum caam_status caam_rng_self_test(vaddr_t baseaddr)
{
	struct caam_jobctx jobctx = {};
	struct caambuf result;
	const uint32_t *rng_self_test_desc = NULL;
	const uint8_t *rng_self_test_exp_result = NULL;
	int ret = CAAM_NO_ERROR;
	int rng_self_test_desc_size = 0;
	int rng_self_test_exp_result_size = 0;
	uint8_t caam_era, rngvid, rngrev;

	caam_era = GET_CCBVID_CAAM_ERA(io_caam_read32(baseaddr + CCBVID));
	rngvid = GET_CHAVID_LS_RNGVID(io_caam_read32(baseaddr + CHAVID_LS));
	rngrev = GET_RNG_VERSION_VID(io_caam_read32(baseaddr + RNG_VERSION));

	if (caam_era < 8 && rngvid == 4 && rngrev < 3) {
		rng_self_test_desc = rng_self_test_desc1;
		rng_self_test_desc_size = ARRAY_SIZE(rng_self_test_desc1);
		rng_self_test_exp_result = rng_self_test_result1;
		rng_self_test_exp_result_size = ARRAY_SIZE(rng_self_test_result1);
	} else if (rngvid != 3) {
		rng_self_test_desc = rng_self_test_desc2;
		rng_self_test_desc_size = ARRAY_SIZE(rng_self_test_desc2);
		rng_self_test_exp_result = rng_self_test_result2;
		rng_self_test_exp_result_size = ARRAY_SIZE(rng_self_test_result2);
	} else {
		EMSG("Invalid CAAM ERA or RNG Version ID or RNG revision");
		return CAAM_FAILURE;
	}

	/* we assume initial setup for CAAM has been performed */

	/* allocate desc */
	jobctx.desc = caam_calloc_desc(rng_self_test_desc_size);
	if (!jobctx.desc) {
		EMSG("Not enough memory for descriptor allocation\n");
		return CAAM_OUT_MEMORY;
	}

	/* allocate result mem */
	ret = caam_calloc_align_buf(&result, rng_self_test_exp_result_size);
	if (ret != CAAM_NO_ERROR)
		goto err;

	/* setup desc */
	caam_desc_init(jobctx.desc);
	caam_desc_add_word(jobctx.desc, DESC_HEADER(0));
	ret = caam_desc_add_self_test(jobctx.desc, rng_self_test_desc,
				      rng_self_test_desc_size, &result);
	if (ret) {
		EMSG("Error in Job Descriptor Construction\n");
		goto err2;
	}

	cache_operation(TEE_CACHEINVALIDATE,
			result.data, result.length);

	ret = caam_jr_enqueue(&jobctx, NULL);
	if (ret != CAAM_NO_ERROR &&
	    ret != CAAM_JOB_STATUS) {
		EMSG("RNG Job Ring Error 0x%08" PRIx32, ret);
		goto err2;
	}

	if (ret == CAAM_JOB_STATUS) {
		if ((JRSTA_SRC_GET(jobctx.status) != JRSTA_SRC(CCB)) ||
		    (JRSTA_CCB_GET_ERR(jobctx.status) !=
		     (JRSTA_CCB_CHAID_RNG | JRSTA_CCB_ERRID_HW))) {
			ret = CAAM_FAILURE;
			goto err2;
		} else {
			ret = CAAM_NO_ERROR;
		}
	}

	/* compare result to expected results */
	if (memcmp(result.data, rng_self_test_exp_result,
		   sizeof(*rng_self_test_exp_result) * rng_self_test_exp_result_size) != 0) {
		EMSG("RNG self test failed\n");
		ret = CAAM_BAD_PARAM;
		goto err2;
	}

	IMSG("RNG self test passed");

err2:
	caam_free_buf(&result);
err:
	caam_free_desc(&jobctx.desc);
	return ret;
}
